
/* :mode=c: */

/*! \page conv1 Conventions
This page gives various conventions used throughout PORUS.

\section terms Some terms

Here are a few terms we've adopted when talking about PORUS.

- \e User \e code is your code.  Presumably it uses PORUS for USB stuff.

- A \e port is a set of back-end code which works with some particular piece of hardware.  To use a port, link the core PORUS files with one of the usbhw.c files.

- The \e core \e code is the code that runs between the port code and your code.  It is the same for every port.

- The \e public \e API is the set of functions declared in the \c usb.h tree and up.  If you are using PORUS, you need the public API; do not use the private functions and hardware functions.

- The \e hardware \e API defines those functions which a port must implement, and some it can optionally implement.  User code should never call any of these directly.

- The \e private \e API is used only by ports and the core.  User code must never touch any of the functions and definitions in the private API.

All of the APIs are documented here, but if you're a user and not writing a port, do not use any functions in \c usbpriv.h or \c usbhw.h , lest you swiftly fall to a certain and terrible doom.

\section datatypes Data types

PORUS uses a number of custom data types.  Definitions are given in \c types.h file.  A default \c types.h is given in the top level, and machine-specific versions, if needed, are kept in the \c port subdirectory (see below).  You can compile with the one included with PORUS, or use your own, but since the headers include it, it must be available.  The default \c types.h should nearly always suffice.

- \c u8 Unsigned 8-bit.  Usually \c unsigned \c char .
- \c s8 Signed 8-bit.  Usually \c char .
- \c u16 Unsigned 16-bit.  Usually \c unsigned \c short .
- \c s16 Signed 16-bit.  Usually \c short .
- \c u32 Unsigned 32-bit.  Usually \c unsigned \c long .
- \c s32 Signed 32-bit.  Usually \c signed \c long .
- \c u64 Unsigned 64-bit.  Usually \c unsigned \c long \c long .
- \c s64 Signed 64-bit.  Usually \c signed \c long \c long .
- \c f32 IEEE-754 floating point, 32 bits.  Usually \c float .
- \c f64 IEEE-754 floating point, 64 bits.  Usually \c double .

The latter two aren't much used.

When width isn't terribly important, usually PORUS code uses \c int for integers and \c float for floating-point.

Boolean values are passed as \c int and use the usual C convention that 0 is false and non-zero is true.

\section sourcefiles Source files

This diagram shows the include relationships between the various source files in PORUS:

\image html includetree.png

The arrows point from a file to a file it includes.

User code only need include \c usb.h .  This contains most all of the PORUS public API, and brings in \c usbconfig.h , which is generated by \c usbdescgen .  \c usbconfig.h brings in some extra headers, since the generated definitions and code need them.

The private code uses \c usbhw.h for everything.  \c usbhw.h is separated from \c usbpriv.h mainly for clarity and to ease porting; any function declared in \c usbhw.h must be implemented, and that's that.

\section naming Function and variable names

All PORUS function names begin with either \c usb_ or \c usbhw_ .  \c usb_ 
is used for functions in the public API.  \c usbhw_ is used for functions in the hardware API.  The functions related only to control endpoints are prefixed \c usb_ctl_ .

PORUS uses a few (gasp!) global variables.  The naming for these is the same as the naming of functions.

PORUS has a lot of accessor functions.  Setter functions are prefixed \c usb_set_ , \c usb_ctl_set_ , or \c usbhw_set_ .  Boolean getter functions are sometimes named with \c _is_ ; getters which report a parameter use \c _get_ .

\section numbers Endpoint numbers

USB provides for sixteen IN endpoints, numbered 0-15, and sixteen OUT endpoints, also numbered 0-15.  Many PORUS functions operate on either IN or OUT endpoints, so PORUS endpoint numbering is a little different:

- Endpoints OUT0-15 are numbered 0-15.
- Endpoints IN0-15 are numbered 16-31.

Another way to look at it: IN endpoint numbers are like OUT endpoint numbers, but with bit 4 set.

The control endpoints are numbers 0 and 16.  These have their own set of functions, and most all of the normal endpoint functions don't accept these numbers.

*/
